//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 15.10.2021.
//
//__________________________________________________________________________________
//                                                                                  |
//                   ОДНОМЕРНОЕ ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ                       |
//                                                                                  |
//    Задача про "Кузнечика - экономиста". Кузнечик прыгает по числовой прямой.     |
//  Прыгает ТОЛЬКО ВПЕРЕД (прямолинейно) и только на одну клеточку (+1) либо на     |
//  две (+2) клеточки до клеточки n. Кузнечик прыгает бесплатно, но стоимость посе- |
//  щения клеток разная.                                                            |
//    Найти стоимость самого дешевого пути, двигаясь из исходной клетки в клетку n. |
//  Обозначения:                                                                    |
//   o                                                                              |
// /()\  <---- Кузнечик-экономист                                                   |
//  /\                                                                              |
//   |===|===|===|===|===|===|===|===|===|===|===|===|===|=========>   <--- путь    |
//   1   2   3   4   5   6   7   8   9  10  11  12  13  14                          |
//  p1  p2  p3  p4  p5  p6... ...^   ^   ^   ^...                                   |
//   ^   ^   ^   ^   ^   ^       |   |   |   |                                      |
//   |___|___|___|___|___|       |___|___|___|                                      |
//    стоимости посещений           клеточки                                        |
//  p - price - стоимость посещения клеточки;                                       |
//  c - cost - общая стоимтость произвольного пути, пройденного по клеточкам        |
//                                                                                  |
//  Начнем с того, что cost пути в клеточку 1 будет равен стоимости посещения этой  |
// клеточки, то есть cost[1] = price[1] или кратко c[1] = p[1]. Во вторую клетку    |
// можно попасть только одним способом: из первой клеточки во вторую, значит стои-  |
// мость пути в клетку 2 будет: c[2] = p[1] + p[2]. В клетку 3 мы можем попасть     |
// двумя способами: либо из клетки 1 сразу в клетку 3 либо сначала из 1 в 2, потом  |
// из 2 в 3 - вспоминаем условие: кузнечик может прыгать либо на одну (+1) либо на  |
// две (+2) клеточки. Значит c[3] = ..?. Давайте рассмотрим какова min cost[i].     |
// Для начала необходимо найти, какой путь дешевле: cost[i-1] или cost[i-2]. И на   |
// основе этого результата найдем min cost[i].                                      |
//                                                                                  |
//                 COST[I] = MIN(COST[I-1], COST[I-2]) + PRICE[I]                   |
//                                                                                  |
//__________________________________________________________________________________|

#include <iostream>

// объявление функции
int minCostShort(int finishPoint, int price[]);

int main(int argc, const char * argv[]){
    // точка назначения (финищная точка)
    int finishPoint;
    // создаем массив стоимостей посещения точек
    int price[101];
    std::cout << "Кузнечик-экономист хочет идти из точки 1 в точку n.\n";
    std::cout << "Введите n: ";
    std::cin >> finishPoint;
    if (finishPoint > 100) {
        std::cout << "Слишком большое число (Вы должны ввести не более 100)!\n";
        return -1;
    }
    
    std::cout << "Введите цены посещаемых точек (начиная с точки 1 до точки "
        << finishPoint << "):"<< '\n';
    for (int i = 1; i <= finishPoint; ++i) {
        std::cin >> price[i];
    }

    std::cout << "Минимальная стоимость достижения точки " << finishPoint
        << " из точки 1: \n" << minCostShort(finishPoint, price) << ".\n";

   
    return 0;
}

int minCostShort(int finishPoint, int price[]){
    int cost[finishPoint + 1];
    // крайние случаи:
    cost[1] = price[1];
    cost[2] = price[1] + price[2];
    
    // динамический случай
    for (int i = 3; i <= finishPoint; ++i) {
        cost[i] = std::min(cost[i - 1], cost[i - 2]) + price[i];
    }
    
    // распечатываем САМ ПУТЬ
    std::cout << "Сам путь (с конца в начало) = [ ";
    int currentPoint = finishPoint;
    std::cout << currentPoint << ' ';
    while (currentPoint != 1) {
        if (cost[currentPoint - 1] == cost[currentPoint] -
                                price[currentPoint]) {
            currentPoint = currentPoint - 1;
        } else if (cost[currentPoint - 2] == cost[currentPoint] -
                                price[currentPoint]) {
            currentPoint = currentPoint - 2;
        } else {
            throw -1; // я никогда не должен попадать в это точку!
        }
        
        std::cout << currentPoint << ' ';
    }
    std::cout << "]\n";
    
    return cost[finishPoint];
}
