//
//  main.cpp
//
//  cppEdu
//
//  Created by Николай Кутузов on 23.08.2021.
//
//__________________________________________________________________________________
//                Выборочная сортировка. ШОВИНИЗМ - подробности ниже.               |
//                                                                                  |
//  Иммется ряд:                                                                    |
//                          200, 0, -10, 1, 0, -50, 25                              |
//                                                                                  |
//  Задача: отсортировать ряд по возрастанию, но не перемещать при этом элементы [0]|
//                                                                                  |
//  Механизм сортировки:                                                            |
//                                                                                  |
//  for (int pos = 0; pos < ((sizeof(people) / sizeof(people[0])) - 1); ++pos){     |
//      if (people[pos] == 0) continue;                                             |
//          for (int i = pos + 1; i < (sizeof(people) / sizeof(people[0])); ++i) {  |
//              if (people[i] < people [pos] and people[i] != 0)                    |
//                  std::swap(people[i], people [pos]);                             |
//          }                                                                       |
//  }                                                                               |
//                                                                                  |
//  Выполнение кода:                                                                |
//                                                                                  |
//  НАЧИНАЯ с нулевого элемента (200) и не доходя последнего (25) делаем:           |
//      ЕСЛИ текущий элемент равен нулю, тогда переходим к следующему [pos++]       |
//          иначе НАЧИНАЯ со следующего и до посленего включительно делаем:         |
//              ЕСЛИ следующий[i] меньше текущего[pos] и следующий[i] НЕ равен нулю:|
//                  МЕНЯЕМ местами следующий[i] и текущий [pos]                     |
//          меняем позицию следующего на 1 [i+1] и продолжаем сравнивать с тек.[pos]|
//              ЕСЛИ следующий[i] меньше текущего[pos] и следующий[i] НЕ равен нулю:|
//                  МЕНЯЕМ местами следующий[i] и текущий [pos]                     |
//          меняем позицию следующего на 1 [i+2], продолжаем пока не дойдем до конца|
//  меняем позицию текущего [pos++] и выполняем следующую операцию - предпоследний  |
//  элемент ряда (25) будет псследним текущим [pos] элементом.                      |
//                                                                                  |
//  Результат выполнения программы:                                                 |
//                                                                                  |
//                              -50 0 -10 1 0 25 200                                |
//__________________________________________________________________________________|

#include <iostream>

int main(int argc, const char * argv[]) {
    int people [] { 200, 0, -10, 1, 0, -50, 25 };   // компилируется начиная с c++11
    
    // начианем с нулевого элемента и до предпоследнего включительно
    for (int pos = 0; pos < ((sizeof(people) / sizeof(people[0])) - 1); ++pos){
        // елси текущий элемент равен нулю переходим к следующей операции
        if (people[pos] == 0) continue;
        // начиная со следующего после текущего и до последнего включительно
        for (int i = pos + 1; i < (sizeof(people) / sizeof(people[0])); ++i) {
            // если следующий меньше текущего[pos] и следующий[i] НЕ равен нулю
            // НЕравность нулю текущего элемента проверяли выше% if (people[pos]==0)
            if (people[i] < people [pos] and people[i] != 0)
                // меняем местами следующий[i] и текущий[pos]
                std::swap(people[i], people [pos]);
            // продолжаем сравнивать текущий[pos], но с увеличенным на 1 индексом
            // с следующими[i] элементами
        }
        // после прохождения всех следующих[i] элементов, увеличиваем на 1 индекс
        // текущего[pos] элемента и начинаем снова сравнивать его со следующими[i]
    }
    
    // распечатываем отсортированный ряд
    for (int pos = 0; pos < (sizeof(people) / sizeof(people[0])); ++pos) {
        std::cout << people[pos] << ' ';
    }
    std::cout << '\n';
    
        return 0;
}
