//
//  main.cpp
//
//  cppEdu
//
//  Created by Николай Кутузов on 11.09.2021.
//
//__________________________________________________________________________________
//                                                                                  |
//                      Поразрядная сортировка RADIX SORT                           |
//                                                                                  |
//      Основная идея заключается в следующем: допустим, имеется ряд:               |
//                                                                                  |
//                  101     011     010     001     111     110                     |
//                                                                                  |
//      Делаем следующее:                                                           |
//      Смотрим на первый разряд и раскладываем по кучкам                           |
//                                                                                  |
//                  101     011     010     001     111     110                     |
//                    ^       ^       ^       ^       ^       ^                     |
//                                                                                  |
//  кучка [0] 010   110                                                             |
//  кучка [1] 101   011   001   111                                                 |
//                                                                                  |
//  Переписываем кучки, начиная с нулевой                                           |
//                                                                                  |
//                  010     110     101     011     001     111                     |
//                   ^       ^       ^       ^       ^       ^                      |
//  Внова смотрим, но уже на второй разряд и раскладываем по кучкам                 |
//                                                                                  |
//  кучка [0] 101   001                                                             |
//  кучка [1] 010   110   011   111                                                 |
//                                                                                  |
//  Переписываем кучки, начиная с нулевой                                           |
//                                                                                  |
//                  101     001     010     110     011     111                     |
//                  ^       ^       ^       ^       ^       ^                       |
//  Внова смотрим, но уже на третий разряд и раскладываем по кучкам                 |
//                                                                                  |
//  кучка [0] 001   010   011                                                       |
//  кучка [1] 101   110   111                                                       |
//                                                                                  |
//  Переписываем кучки, начиная с нулевой                                           |
//                                                                                  |
//                  001     010     011     101     110     111                     |
//                                                                                  |
//  ВСЕ! - отсортировали!!! ;)                                                      |
//                                                                                  |
//      Как же происходит магия? Мы как бы приоткрываем с каждым проходом глаза:    |
//   на ряд      101     011     010     001     111     110 мы смотрим сначала:    |
//      по порвому разряду и упорядывачием его:                                     |
//                  01[0]     11[0]     10[1]     01[1]     00[1]     11[1]         |
//      по второму и снова упорядывачием:                                           |
//                  1[01]     0[01]     0[10]     1[10]     0[11]     1[11]         |
//      по третьему и упорядывачием окончательно:                                   |
//                  [001]     [010]     [011]     [101]     [110]     [111]         |
//                                                                                  |
//  Что примечательно - если 1'000'000 чисел - это 20 проходов (2^20 = 1'048'576)   |
//  Асимптотика - O(M * N), М - штук проходов, N - чисел в каждом проходе, но       |
//  потребуется дополнительная память под временное хранение "кучек".               |
//  М = log по основанию 2 от (махA[i]), где махA[i] -,грубо говоря, размера макси- |
//  мального числа. Мы говорим про двоичные числа. Почему он не используется? -     |
//  из-за НЕУНИВЕРСАЛЬНОСТИ - мне не сможем так сортировать, например, вещественные |
//  числа, не можем сортировать пары чисел - например есть Х и У или имя и фамилия. |
//                   Она хороша как СПЕЦИАЛЬНАЯ СОРТИРОВКА!!!                       |
//__________________________________________________________________________________|

#include <iostream>

void generateRandomArray(int arr[], int arrLength, int numberLimit);
void radixSort(int arr[], int arrLength);
void printArray(int arr[], int arrLength);

int main(int argc, const char * argv[]) {
    std::cout << "Введите размер массива: ";
    int arrLength;
    std::cin >> arrLength;
    int arr[arrLength];
    std::cout << "Введите предел максимального генерируемого числа: ";
    int numberLimit;
    std::cin >> numberLimit;
    
//  генерируем случайный массив (+ 1 - чтобы макс. число включительно)
    generateRandomArray(arr, arrLength, numberLimit + 1);
//  распечатываем случайно сгенерированный массив
    printArray(arr, arrLength);
//  сортируем массив
    radixSort(arr, arrLength);
// распечатываем отсортированный массив
    printArray(arr, arrLength);
    
    return 0;
}

//  генерируем случайный массив из целых чисел
void generateRandomArray(int arr[], int arrLength, int numberLimit) {
    for (int i = 0; i < arrLength; ++i) {
        arr[i] = rand() % numberLimit;
    }
}

//  сортируем массив методом "поразрядной сортировки"
//  ОТРИЦАТЕЛЬНЫЕ ЧИСЛА ОН НЕ ОТСОРТИРУЕТ!!!
void radixSort(int arr[], int arrLength) {
    int *arrOfZero = new int[arrLength];          // создаем массив нолей
    int *arrOfUnit = new int[arrLength];          // создаем массив единиц

// Предположим, что int - это 32 разряда
    int radixLimit = 32;
    for (int radix = 0; radix < radixLimit; ++radix) {
// Определяем начальные размеры кучек:
        int arrOfZeroSize = 0;
        int arrOfUnitSize = 0;
    
// Раскладываем на две кучки:
        for (int i = 0; i < arrLength; ++i) {
            //  & (1 << radix) - что это???
            // Это битовое И (&) и
            // единица, сдвинутая влево на
            // radix, то есть на количество
            // разрядов. Что же это такое:
            // есть [0 0 0 0 0 0 0 1]
            // сдвигаем на << 2 и получаем
            // все биты этого числа переношу
            // налево на 2 и получаем:
            // [0 0 0 0 0 1 0 0]
            if ((arr[i] & (1 << radix)) == 0) {   // сдвигаем на radix, чтобы вычленить нужный бит
                arrOfZero[arrOfZeroSize] = arr[i];    // если в разряде 0 - кладем в кучку с нулями
                arrOfZeroSize++;                // и переходим на следующий индекс
            } else {
                arrOfUnit[arrOfUnitSize] = arr[i];    // если в разряде 1 - кладем в кучку с единицами
                arrOfUnitSize++;                // и переходим на следующий индекс
            }
        }
        // По итогам этого прохода все числа будут разложены по двум кучкам: с нулями и с единицами
    
// Теперь соединяем наши кучки:
        // сначала кучка с нулями в опорном разряде
        for (int i = 0; i < arrOfZeroSize; ++i) {
            arr[i] = arrOfZero[i];
        }
        
        // теперь кучка с единицами в опорном разряде
        // но нужно докидывать элементы после уже
        // имеющихся после прохода предидужего цикла
        // Значит будем помещать новые элементы в i-тые
        // ячейки с индексами, сдвинутыми на arrZeroSize
        for (int i = 0; i < arrOfUnitSize; ++i) {
            arr[arrOfZeroSize + i] = arrOfUnit[i];
        }
    }
    
        // высвобождаем память
        delete[] arrOfZero;
        delete[] arrOfUnit;
}

//  распечатываем массив: отсортированный
//  или еще не отсортированный - все зависит
//  от места вызова функции!
void printArray(int arr[], int arrLength) {
    for (int i = 0; i < arrLength; ++i) {
        std::cout << arr[i] << '\t';
    }
    std::cout << std::endl;
}
