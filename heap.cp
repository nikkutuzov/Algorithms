//
//  main.cpp
//
//  cppEdu
//
//  Created by Николай Кутузов on 23.08.2021.
//
//__________________________________________________________________________________
//                    СТРУКТУРА ДАННЫХ - ПИРАМИДА, ОНА ЖЕ КУЧА                      |
//                                                                                  |
//      Задача: БЫСТРО вернуть МАКСИМАЛЬНОЕ значение из сохраненных элементов.      |
//  БЫСТРО удалить его из этой структуры (в смысле какого-то, например, массива).   |
//      Первый вопрос: а почему не подойдет ОТСОТИРОВАННЫЙ массив? Так как у нас    |
//  массив уже отсортирован, асимптотика поиска МАКСИМАЛЬНОГО значения равна O(1).  |
//  Асимптотика удаления последнего (он же НАИБОЛЬШИЙ, так как массив у нас отсор-  |
//  тирован по возрастанию) тоже равна O(1).                                        |
//      ОТВЕТ: Но нам нужно еще и БЫСТРО вставлять вновь прибывший элемент, а он    |
//  может оказаться самым маленьким, следовательно, придется сдвигать ВСЕ эелементы |
//  массива. А это асимптотика, равная O(n).                                        |
//                                                                                  |
//      ИДЕЯ:                                                                       |
//      Построим "дерево":                                                          |
//             *                                                                    |
//          /     \                                                                 |
//         *       *                                                                |
//        / \     / \                                                               |
//       *   *   *   *                                                              |
//      / \ / \ /                                                                   |
//     *  * * * *                                                                   |
//                                                                                  |
//             *  <- Корень дерева                                                  |
//          /    _\____                                                             |
//         *    |  *   |<- Если рассмотреть произольную часть дерева отдельно,      |
//        / \   | / \  | будет ясно, что его вершина явно содержит БОЛЬШИЙ элемент  |
//       *   *  |*   * | по отношению к его ветвям. По правилам транзитивности,     |
//      / \ / \ /------  если [a > b], а [b > c] => [a > c]. Значит нам не нужно    |
//     *  * * * *        явно проверять, что вершина всего дерева содержит элемент  |
//                       БОЛЬШЕ, чем элемент в вершине любого куска дерева.         |
//                                                                                  |
//  Соответственно элементу, стоящему в корне, достаточно быть БОЛЬШЕ его дочерних  |
//  элементов, чтобы можно было совершенно точно утверждать, что он БОЛЬШЕ всех     |
//  остальных элементов!                                                            |
//      Второй вопрос: а как организовать хранение такого дерева?                   |
//      ОТВЕТ: потребуется обычный массив.                                          |
//  Попробуем наполнить дерево индексами массива:                                   |
//                                                                                  |
//                 0                                                                |
//             /      \                                                             |
//            1        2                                                            |
//           / \      / \                                                           |
//          3   4    5   6                                                          |
//         / \ / \  /                                                               |
//        7  8 9 10 11                                                              |
//  Попробуем наполнить дерево значениями элементов:                                |
//                                                                                  |
//                23                                                                |
//             /      \                                                             |
//            17       6                                                            |
//           / \      / \                                                           |
//         14   16   3   1                                                          |
//         / \ / \  /                                                               |
//       13 10 11 8 2                                                               |
//                                                                                  |
//  Выпишим массив: [ 23   17   6   14   16   3   1   13   10   11   8   2 ]        |
//                                                                                  |
//      Теперь представим, что пришло число 7 и нам нужно вставить его в массив     |
//  в нужное место. Сначала ставим его в конец массива, а значит на новую ветку     |
//  дерева. Пробелов быть НЕ ДОЛЖНО!                                                |
//                                                                                  |
//                23                                                                |
//             /      \                                                             |
//            17       6                                                            |
//           / \      / \                                                           |
//         14   16   3   1                                                          |
//         / \ / \  / \                                                             |
//       13 10 11 8 2 [7]                                                           |
//                     ^                                                            |
//                     |                                                            |
//                новый элемент                                                     |
//                                                                                  |
// Как в игре "Царь горы" СЕМЕРКА начинает лезть, "спихивая" меньшие элементы вниз  |
//                23                                                                |
//             /      \                                                             |
//            17       6                                                            |
//           / \      / \                                                           |
//         14   16  [7]  1     <-|ТРОЙКА уходит вниз, а СЕМЕРКА на ее место         |
//         / \ / \  / \          |                                                  |
//       13 10 11 8 2  3 <-------|Собственно, они меняются местами, идя по веткам   |
//                                                                                  |
//                23                                                                |
//             /      \                                                             |
//            17      [7]      <-|ШЕСТЕРКА уходит вниз, а СЕМЕРКА на ее место       |
//           / \      / \        |                                                  |
//         14   16   6<--1-------|Собственно, они меняются местами, идя по веткам   |
//         / \ / \  / \                                                             |
//       13 10 11 8 2  3                                                            |
//                                                                                  |
//  Выпишим массив: [ 23   17   7   14   16   6   1   13   10   11   8   2   3 ]    |
//                                                                                  |
//  Всего ТРИ сравнения: с ТРОЙКОЙ, с ШЕСТЕРКОЙ и с ДВАДЦАТЬ ТРИ.                   |
//  Получается, что в наихудшем случае асимптотика вставки элемента в дереве равна  |
//  O(H), где Н - высота дерева. Высота дерева равна расстоянию от корня дерева до  |
//  самой удаленной вершины, точнее "листочка".                                     |
//                                                                                  |
//      Теперь рассмотрим удаление МАКСИМАЛЬНОГО элемента из этого массива/пирамиды |
//               [  ]  <- Удаляем максимальное                                      |
//             /      \                                                             |
//            17       7                                                            |
//           / \      / \                                                           |
//         14   16   6   1                                                          |
//         / \ / \  / \                                                             |
//       13 10 11 8 2  3                                                            |
//      Во-первых нужно заполнить пустоту!                                          |
//                                                                                  |
//               [3]  <- 2. ...ставим его на место удаленного                       |
//             /      \  ^___________________________________                       |
//            17       7                                     |                      |
//           / \      / \                                    |                      |
//         14   16   6   1                                   |                      |
//         / \ / \  /                                        |                      |
//       13 10 11 8 2 [ ] <- 1. Берем последний элемент и..._|                      |
//                                                                                  |
//                3                                                                 |
//             /      \                                                             |
//            17 <-->  7  <- Сравниваем дочерние только что заполненного элемента   |
//           / \      / \                                                           |
//         14   16   6   1                                                          |
//         / \ / \  /                                                               |
//       13 10 11 8 2                                                               |
//      17 БОЛЬШЕ 7 и сравниваем с ТРОЙКОЙ, тройка меньше => меняем местами         |
//                                                                                  |
//                                          17                                      |
//                                       /      \                                   |
//                                      3        7                                  |
//                                     / \      / \                                 |
//  Сравниваем дочерние -----------> 14<->16   6   1                                |
//                                   / \ / \  / \                                   |
//                                 13 10 11 8 2  3                                  |
//      16 БОЛЬШЕ 14, сравниваем с ТРОЙКОЙ, тройка меньше => меняем местами         |
//                                                                                  |
//                17                                                                |
//             /      \                                                             |
//            16       7                                                            |
//           / \      / \                                                           |
//         14   3    6   1                                                          |
//         / \ / \  /                                                               |
//       13 10 11 8 2                                                               |
//             ^  ^                                                                 |
//             \  /                                                                 |
//          Сравниваем дочерние                                                     |
//                                                                                  |
//                17                                                                |
//             /      \                                                             |
//            16       7                                                            |
//           / \      / \                                                           |
//         14   11    6   1                                                         |
//         / \ / \  /                                                               |
//       13 10 3 8 2                                                                |
//      11 БОЛЬШЕ 8, сравниваем с ТРОЙКОЙ, тройка меньше => меняем местами          |
//                                                                                  |
//  Выпишим массив: [  17   16   7   14   11   6   1   13   10   3   8   2 ]        |
//                                                                                  |
//  Таким образом мы немного пожертвовав асимптотикой удаления элемента в итоге     |
//  получили следующие значения: асимптотика поиска максимального значения - O(1)   |
//  асимптотика удаления - O(H), асимптотика вставки нового элемента -  O(H), где   |
//  H - высота дерева. Отказавшись от отсортированного массива мы немного потеряли  |
//  на удалении элемента, зато много выиграли на вставке нового.                    |
//      Третий вопрос: а как найти индексы дочерних элементов?                      |
//      ОТВЕТ:                                                                      |
//                 0                                                                |
//             /      \                                                             |
//            1        2                                                            |
//           / \      / \                                                           |
//          3   4    5   6                                                          |
//         / \ / \  /                                                               |
//        7  8 9 10 11                                                              |
//  Имеем: у 0го - 1 и 2, у 1го - 3 и 4, у 4го - 9 и 10 и т.д.                      |
//  Значит:                                                                         |
//      индекс левого дочернего эл-та       индекс правого дочернего эл-та          |
//      индеск родительского, умноженного   индеск родительского, умноженного       |
//      на ДВА и плюс ОДИН                  на ДВА и плюс ДВА                       |
// index[leftChild]=index[parrent] * 2 + 1 index[rightChild]=index[parrent] * 2 + 2 |
//  Индекс родительского элемента: индекс дочернего минус ОДИН, разделенного на ДВА |
//  С ОТБРАСЫВАНИЕМ ОСТАТКА! Рассмотрим пример на индексах 7 и 8:                   |
//  (7 - 1) / 2 = 3 и (8 - 1) / 2 = 3, если отбросить остаток.                      |
//__________________________________________________________________________________|


#include <iostream>
// по сути пирамида/куча - бинарное дерево, а его можно рассматривать
// как динамический массив, для этого будем использовать вектор
#include <vector>

// создаем синоним типа
typedef int heapData_t;
// heapData_t - тип элемента в пирамиде/куче
// делается это для удобства, например: сейчас мне нужно, чтобы
// в куче были int'ы, а если вдруг я захочу чтобы были строки,
// я ТОЛЬКО ТУТ поменяю int на std::string
//
// создаем синоним
typedef std::vector<heapData_t> heap_t;
// heap_t - сама пирамида/куча

//
// создаем прототипы функции
//

// возвращает значение элемента на вершине пирамиды/кучи
// функция принимает в качестве параметра КОНСТАНТНУЮ ссылку
// на кучу, так как в этой функции МЕНЯТЬ НИЧЕГО НЕ НУЖНО!
heapData_t top(const heap_t &h);

// функция убирает значение из вершины пирамиды/кучи, значит кучу
// нужно менять, соответсвенно параметром будет ссылка
// НЕКОНСТАНТНАЯ на кучу! Возвращаемое значение нужно только
// для информации. Можно сделать и void
heapData_t pop(heap_t &h);

// добавить новый элемент в кучу значит пирамидукучу передаем как
// параметр функции опять же по ссылке, но НЕ КОНСТАНТНОЙ!!!
// Принимет значение, которое будем вставлять
// Функция ничего не возвращает => void
void push(heap_t &h, heapData_t x);

// функция проверки кучи на пустоту
bool isEmpty(heap_t &h);

int main(int argc, const char * argv[]) {
// создаем нашу пирамиду/кучу - вектор!
    heap_t myHeap;
    
    heapData_t x;
    std::cin >> x;
// пока не ввели число 0 будем вставлять в пирамиду значения
    while (x != 0) {
        push(myHeap, x);
        std::cin >> x;
    }
// пока пирамида/куча не пустая печатать элементы вершины
    while (not isEmpty(myHeap)) {
        std::cout << pop(myHeap) << '\t';
    }
    std::cout << '\n';
    
    return 0;
}

//
// РЕАЛИЗАЦИИ ФУНКЦИЙ
//

heapData_t top(const heap_t &h) {
    return h[0];
}

heapData_t pop(heap_t &h) {
    using namespace std;         // для использования ::size_type
    
    heapData_t value = h[0];    // запоминаем последний элемент
    h[0] = h.back();            // забрасываем последний наверх пирамиды/кучи
    h.pop_back();               // удаляем последний элемент
    
    // битва за вершину пирамиды
    heap_t::size_type currentIndex = 0;             // текущий элемент
    heap_t::size_type left = 2 * currentIndex + 1;  // левый дочерний
    heap_t::size_type right = 2 * currentIndex + 2; // правый дочерний
    
    // автоматически, так как уже проверяли в условии входа
    // в цикл, что левый дочерний существует и он больше текущего или
    // правый дочерний существует и он больше текучего
    while (((left < h.size()) and (h[left] > h[currentIndex])) or
           ((right < h.size()) and (h[right] > h[currentIndex]))) {
        
        // правого элемента не существует или левый больше правого
        if ((right >= h.size()) or (h[left] > h[right])) { //оп. or - ленивый!!!
            swap(h[left], h[currentIndex]);
            currentIndex = left;
        } else {
            swap(h[right], h[currentIndex]);
            currentIndex = right;
        }
        left = 2 * currentIndex + 1;
        right = 2 * currentIndex + 2;
    }
    
    return value;               // передаем запомненное  в вызывающую функцию
}

void push(heap_t &h, heapData_t x) {
    using namespace std;        // для использования ::size_type
    h.push_back(x);
    // попытка подъема на вершину пирамиды
    heap_t::size_type currentIndex =
                    h.size() - 1; // heap_t::size_type - какой тип для
    heap_t::size_type parentIndex =
                    (currentIndex - 1) / 2;  // индекса вектора (size_type >= 0)
    while (currentIndex != 0 and h[currentIndex] > h[parentIndex]) {
        swap(h[currentIndex], h[parentIndex]);
        currentIndex = parentIndex;
        parentIndex = (currentIndex - 1) / 2;
    }
}

bool isEmpty(heap_t &h) {
    return h.size() == 0;
}
