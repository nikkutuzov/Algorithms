//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 18.10.2021.
//
//__________________________________________________________________________________
//                                                                                  |
//                      ДВУМЕРНОЕ ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ                     |
//                                                                                  |
//                              РАССТОЯНИЕ ЛЕВЕНШТЕЙНА                              |
//                                                                                  |
//      Расстояние Левенштейна(редакционное расстояние, дистанция редактирования) - |
//  метрика, измеряющая по модую разность между двумя последовательностями символов.|
//  Она определяется как минимальное количество односимвольных операций (а именно   |
//  вставки, удаления, замены), необходимых для превращения одной последователь-    |
//  ности символов в другую. Предположим, что у нас есть строки: string master      |
//                                                                                  |
//                             стр. а    стр. b                                     |
//                          L('string', 'master')                                   |
//                      |--------------------------|                                |
//      Предположим, что нам известны результаты решений следующих расстояний:      |
//                         |        |       |                                       |
//                         |        |       |====> L('string', 'maste')             |
//                         |        |                                               |
//                         |        |====> L('strin', 'master')                     |
//                         |                                                        |
//                         |====> L('strin', 'maste')                               |
//  Смотрим на последние символы и если они одинаковые, то решением задачи будет    |
//  решение последнего L('strin', 'maste') расстояния Левенштейна. В качестве при-  |
//  мера рассмотрим следующее:                                                      |
//          Имеется пара: А Б В                                                     |
//                        Г Д                                                       |
//      Решением будет: 1 - А заменили на Г, Б - заменили на Д, В удалили, то есть 3|
//      Если бы пары были: А Б В Т                                                  |
//                         Г Д Т, то Т - совпадают, а остальное так же, то есть 3   |
//      Если же последние символы НЕ совпадают - как у нас - тогда решение сводится |
//  к первому либо ко второму решению. Получаем формулу:                            |
//                                                                                  |
//                         L('string', 'master') = L[6, 6]                          |
//  тогда вычислим L[i, k] (i - по вертикали(номер строки) k - по вертикали(номер   |
//  элемента в строке) - расстояние между подстроками длины i и k:                  |
//            | L[i-1, k-1], если a[i] = b[i]                                       |
//  L[i, k] =<| !!!так как индексы начинаются с 0, то a[i-1] = b[i-1]!!!            |
//            | min(L[i-1, k], L[i, k-1], L[i-1, k-1]) + 1, если  a[i-1] != b[i-1]  |
//  Рекурсия, по крайней мере для ДЛИННЫХ строк, не пойдет. Будем использовать      |
//  ДВУМЕРНОЕ ДИНАМИЧЕСКОЕ ПРОГРАММИРОВАНИЕ                                         |
//                                                                                  |
//  Примечание: чему равно L[0, k] и L[i, 0] - L[0, k] = k и L[i, 0] = i, потому    |
//  что: берем две строки 'string' и '' - чтобы получилась вторая строка нужно было |
//  удалить ШЕСТЬ символов. Или '' и 'master' - добавить ШЕСТЬ символов.            |
//                                                                                  |
//                                                                                  |
//                  ПРИМЕР РАБОТЫ АЛГОРИТМА                                         |
//                                                                                  |
//           P    O    L    Y    N    O    M    I    A    L                         |
//    ______________________________________________________                        |
//   |  0    1    2    3    4    5    6    7    8    9    10                        |
// E |  1    1    2    3    4    5    6    7    8    9    10                        |
// X |  2    2    2    3    4    5    6    7    8    9    10                        |
// P |  3    2    3    3    4    5    6    7    8    9    10                        |
// O |  4    3    2    3    4    5    5    6    7    8    9                         |
// N |  5    4    3    3    4    4    5    6    7    8    9                         |
// E |  6    5    4    4    4    5    5    6    7    8    9                         |
// N |  7    6    5    5    5    4    5    6    7    8    9                         |
// T |  8    7    6    6    6    5    5    6    7    8    9                         |
// I |  9    8    7    7    7    6    6    6    6    7    8                         |
// A | 10    9    8    8    8    7    7    7    7    6    7                         |
// L | 11   10    9    8    9    8    8    8    8    7    6                         |
//__________________________________________________________________________________|

#include <iostream>
#include <vector>

//объявление функуции
int LevenstainDistance(std::string a, std::string b);

int main(int argc, const char * argv[]){
    std::cout << "Расстояние Левенштейна!" << std::endl;
    std::string a;
    std::string b;
    std::cout << "Введите первою строку: ";
    getline(std::cin, a);
    std::cout << "Введите вторую строку: ";
    getline(std::cin, b);
    
    std::cout << "Расстояние Левенштейна равно: "
            << LevenstainDistance(a, b) << std::endl;
    
    return 0;
}

//определение функуции
int LevenstainDistance(std::string a, std::string b){
    std::vector<std::vector<int>> Levetnine;
    Levetnine.resize(a.length() + 1);
    for (int i = 0; i <= a.length(); ++i) {
        Levetnine[i].resize(b.length() + 1);
    }
    
    // базовые случаи:
    for (int i = 0; i <= a.length(); ++i) {
        Levetnine[i][0] = i;
    }
    for (int k = 0; k <= b.length(); ++k) {
        Levetnine[0][k] = k;
    }
    
    // рекуррентный случай:
    for (int i = 1; i <= a.length(); ++i) {
        for (int k = 1; k <= b.length(); ++k) {
            if (a[i - 1] == b[k - 1]) {  // если последние символы совпадают
                Levetnine[i][k] = Levetnine[i - 1][k - 1];
            } else { // иначе нужно удалить/добавить последний символ в строке a или b
            Levetnine[i][k] = std::min(std::min(Levetnine[i - 1][k], Levetnine[i][k - 1]),
                                       Levetnine[i - 1][k - 1]) + 1;
            }
        }
    }
    
    return Levetnine[a.length()][b.length()];
}
