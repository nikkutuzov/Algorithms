//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 08.10.2021.
//
//__________________________________________________________________________________
//              РЕКУРСИЯ НА ПРИМЕРЕ "MergeSort - сортировка СЛИЯНИЕМ"               |
//                                                                                  |
//    Ключевая идея состоит в том, что сортирующее действие осуществляется ПОСЛЕ    |
//  декомпозиции - то есть, ПОСЛЕ ВХОДА В РЕКУРСИЮ! Для примера рассмотрим массив:  |
//                                                                                  |
//            [ 2   8   11   10   13   1   3   16   14   6   17   23 ]              |
//  Разделим примерно пополам:                                                      |
//                                       |                                          |
//            [ 2   8   11   10   13   1 | 3   16   14   6   17   23 ]              |
//                                       |                                          |
//      НАЧИНАЕМ МЕЧТАТЬ, что ЛЕВАЯ и ПРАВАЯ стороны были кем-то отсортированы!     |
//                                       |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//                                       |                                          |
// Начинаем сравнивать ЛЕВЫЕ и ПРАВЫЕ элементы по порядку и класть в ИТОГОВЫЙ МАССИВ|
//                                                                                  |
//                                       |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//              ^                        | ^                                        |
//              |                          |                                        |
//              L                          R                                        |
//     L < R:                                                                       |
//            [ 1                                                    ]              |
//              ^                                                                   |
//              |                                                                   |
//            INDEX                                                                 |
//      L + 1, INDEX + 1                                                            |
//                                                                                  |
//                                       |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//                  ^                    | ^                                        |
//                  |                      |                                        |
//                  L                      R                                        |
//     L < R:                                                                       |
//            [ 1   2                                                ]              |
//                  ^                                                               |
//                  |                                                               |
//                INDEX                                                             |
//      L + 1, INDEX + 1                                                            |
//                                                                                  |
//                                       |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//                      ^                | ^                                        |
//                      |                  |                                        |
//                      L                  R                                        |
//     L > R:                                                                       |
//            [ 1   2   3                                            ]              |
//                      ^                                                           |
//                      |                                                           |
//                    INDEX                                                         |
//      L + 1, INDEX + 1                                                            |
//                                                                                  |
//                                       |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//                      ^                |     ^                                    |
//                      |                      |                                    |
//                      L                      R                                    |
//     L > R:                                                                       |
//            [ 1   2   3   6                                        ]              |
//                          ^                                                       |
//                          |                                                       |
//                        INDEX                                                     |
//      R + 1, INDEX + 1                                                            |
//      ну и так далее...                                                           |
//                                                                                  |
//      ...пока не наступает ситуация:   |                                          |
//            [ 1   2   8   10   11   13 | 3   6   14   16   17   23 ]              |
//                                     ^ |         ^____^____^____^                 |
//                                     |           |      ||                        |
//                                     L           R      ||                        |
//                                       \                ||                        |
//                                        \               ||                        |
//                                         \              ||                        |
//     L < R:                               \             \/                        |
//            [ 1   2   3   6   8   10   11   13                     ]              |
//                          ^                                                       |
//                          |                                                       |
//                        INDEX                                                     |
//      ВНИМАНИЕ! ЛЕВАЯ сторона закончилась, но по нашим МЕЧТАМ ПРАВАЯ сторона тоже |
//  была отсортирована, так что просто переносим ее в ИТОГОВЫЙ МАССИВ как есть.     |
//  НО! Вернемся от мечтаний в реальность. Как видно - рекурсия просится!           |
//      Чтобы внести ясность в вопросе про рекурсию: когда мы мечтали, что после    |
//  того как мы разделили изначальный массив примерно пополам и представили, что    |
//  эти две части отсортированы, мы можем представить тоже самое. И, рассмотрев     |
//  каждую из частей в отдельности, увидеть, что каждую часть мы так же делим       |
//  примерно пополам. И получившиеся части у нас в свою очередь тоже будут отсор-   |
//  тированы. Что же относительно крайнего случая? КРАЙНИЙ СЛУЧАЙ наступает тогда,  |
//  когда в функцию передается РАЗМЕР МАССИВА МЕНЬШЕ ЛИБО РАВЕН ЕДИНИЦЕ!            |
//__________________________________________________________________________________|

#include <iostream>

// Макимально возможный размер массива
const int MAX_ARRAY_SIZE = 10000;

//  объявление функций
void inputArray(double *arr, int16_t arraySize);
void mergeSort(double *arr, int16_t arraySize);
void printArray(double *arr, int16_t arraySize);

int main(int argc, const char * argv[]) {
    int16_t arraySize;
    std::cout << "Введите размер массива: ";
    std::cin >> arraySize;
    if (arraySize < 0 or arraySize > MAX_ARRAY_SIZE) {
        std::cout << "Размер массива либо меньше нуля либо слишком большой!\n";
        return 1;
    }
    double *arr = new double[arraySize]; //выделяем память для массива

    inputArray(arr, arraySize);
    mergeSort(arr, arraySize);
    printArray(arr, arraySize);

    delete[] arr; //высвобождаем память
    
    return 0;
}

//  определение функций

void inputArray(double *arr, int16_t arraySize){
    for (int i = 0; i < arraySize; ++i) {
        std::cin >> arr[i];
    }
}

void mergeSort(double *arr, int16_t arraySize){
    
    //крайний случай!
    if (arraySize <= 1)
        return;
    
    //находим СЕРЕДИНУ (или примерно середину для нечетной длины) массива
    int16_t middle = arraySize / 2;
    double *left = arr;
    double *right = arr + middle;

    int16_t leftSize = middle;
    //ВНИМАНИЕ! Адресная арифметика С++ позволяет:
    //адрес + число в результате дает смещение НАЧАЛА массива! То есть
    //в нашем случае дает НАЧАЛО правой части массива (после разделителя!)
    int16_t rightSize = arraySize - leftSize;
    
//рекуррентные вызовы
    //сортируем левую часть
    mergeSort(left, leftSize);
    //сортируем правую часть
    mergeSort(right, rightSize);

    // Объединение двух отсортированных частей в итоговый массив
        //создаем временный массив для слияния
    double *buffer = new double[arraySize]; //выделяем память для массива
    int16_t leftCurrentIndex = 0;
    int16_t rightCurrentIndex = 0;
    int16_t bufferCurrentIndex = 0;
    
    // до тех пор пока хотя бы одна из частей закончилась (стала пустой)
    while (leftCurrentIndex < leftSize and rightCurrentIndex < rightSize) {
        // если текущий элемент в левой части меньше либо равен правому текущему
        if (left[leftCurrentIndex] <= right[rightCurrentIndex]) {
            // берем элемент из левой части и кладем во временный массив buffer
            buffer[bufferCurrentIndex] = left[leftCurrentIndex];
            // сдвигаем индексы в левой части и во временном массиве
            ++leftCurrentIndex;
            ++bufferCurrentIndex;
        } else {
            // берем элемент из правой части и кладем во временный массив buffer
            buffer[bufferCurrentIndex] = right[rightCurrentIndex];
            // сдвигаем индексы в правой части и во временном массиве
            ++rightCurrentIndex;
            ++bufferCurrentIndex;
        }
            
    }
    // ОБРАЩАЕМ ВНИМАНИЕ! переменные НЕ инициализируются вторично!
    // продолжается копирование элементов из левого массива (если/пока таковые есть)
    while (leftCurrentIndex < leftSize) {
        buffer[bufferCurrentIndex] = left[leftCurrentIndex];
        // сдвигаем индексы в правой части и во временном массиве
        ++leftCurrentIndex;
        ++bufferCurrentIndex;
    }
    
    // продолжается копирование элементов из правого массива (если/пока таковые есть)
    while (rightCurrentIndex < rightSize) {
        buffer[bufferCurrentIndex] = right[rightCurrentIndex];
        ++rightCurrentIndex;
        ++bufferCurrentIndex;
    }

    //копируем из временного массива в ИТОГОВЫЙ
    for (int16_t i = 0; i < arraySize; ++i) {
        arr[i] = buffer[i];
    }
    
    delete[] buffer; //высвобождаем память
}

void printArray(double *arr, int16_t arraySize){
    for (int i = 0; i < arraySize; ++i) {
        std::cout << arr[i] << "   ";
    }
    std::cout << '\n';
}
