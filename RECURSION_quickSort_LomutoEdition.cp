//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 08.10.2021.
//
//__________________________________________________________________________________
//              РЕКУРСИЯ НА ПРИМЕРЕ "QuickSort - сортировка Тони Хоара"             |
//                                                                                  |
//      Ключевая идея состоит в том, что сортирующее действие осуществляется ДО     |
//  декомпозиции - то есть, ДО ВХОДА В РЕКУРСИЮ! Сначала ПРОИЗВОЛЬНО выбираем некий |
//  ОПОРНЫЙ ЭЛЕМЕНТ из сортируемого массива. Для примера рассмотрим массив:         |
//                                                                                  |
//            [ 2   8   11   10   13   1   3   16   14   6   17   23 ]              |
//                           ^                                                      |
//                           |                                                      |
//             Случайно выбирим ОПОРНЫЙ ЭЛЕМЕНТ                                     |
//      И раскидаем массив на два - СЛЕВА и СПРАВА от ОПОРНОГО ЭЛЕМЕНТА (если       |
//  меньше ОПОРНОГО - налево, больше либо равно - направо.                          |
//             2   8   1   3   6   [10]   11   13   16   14   17   23               |
//                                  ^                                               |
//                                  |                                               |
//                          ОПОРНЫЙ ЭЛЕМЕНТ                                         |
//      Массив предварительно отсортирован относительно ОПОРНОГО ЭЛЕМЕНТА. Далее    |
//  переходим к декомпозиции, то есть проводим такие же действия с ЛЕВОЙ и ПРАВОЙ   |
//  частями:                                                                        |
//      Левая часть: произвольно выбираем ОПОРНЫЙ ЭЛЕМЕНТ:                          |
//             2   8   1   3   6                                                    |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//      И раскидаем массив на два - СЛЕВА и СПРАВА от ОПОРНОГО ЭЛЕМЕНТА (если       |
//  меньше ОПОРНОГО - налево, больше или равно - направо.                           |
//                    [1]   2   8   3   6                                           |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//      Кучка слева от ОПОРНОГО ЭЛЕМЕНТА пуста, а справа нет, значит подобно же     |
//  отсортируем. ВАЖНО! Крайним случаем будет считаться, когда массив будет иметь   |
//  длину, равную ОДНОМУ - массив сортировать не нужно, либо НОЛЬ.                  |
//                                                                                  |
//      У нас появился первый элемент итогового массива: 1, потому что слева от него|
//  ничего нет. Если бы от него слева (или спава при рассмотрении элементов больше  |
//  опорного) находился бы ТОЛЬКО ОДИН элемент,то они попали бы в итоговый массив   |
//  ПАРОЙ! Итак, итоговый массив становиться...                                     |
//                                                                                  |
//            [ 1...                                                 ]              |
//                                                                                  |
//             2   8   3   6                                                        |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//                2   [3]   8   6                                                   |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//  Слева оказался один элемент - сортировать не нужно и мы ПАРУ - левый и ОПОРНЫЙ  |
//  включаем в итоговый массив, справа - два, сортируем                             |
//      Итоговый массив становиться...                                              |
//            [ 1   2   3...                                         ]              |
//                         [8]    6                                                 |
//                          ^                                                       |
//                          |                                                       |
//                  ОПОРНЫЙ ЭЛЕМЕНТ                                                 |
//      ПОЛУЧАЕМ:                                                                   |
//                     6   [8]                                                      |
//                          ^                                                       |
//                          |                                                       |
//                  ОПОРНЫЙ ЭЛЕМЕНТ                                                 |
//      Итоговый массив становиться...                                              |
//            [ 1   2   3   6   8   [10]                             ]              |
//                                   ^                                              |
//                                   |                                              |
//                    первый ОПОРНЫЙ ЭЛЕМЕНТ                                        |
//      ДЕЛАЕМ ТОЖЕ САМОЕ С ПРАВОЙ ПОЛОВИНОЙ относительо первого ОПОРНОГО ЭЛЕМЕНТА  |
//      У этой сортировки выбор ОПОРНОГО ЭЛЕМЕНТА имеет очень большое значение!     |
//  Если ОПОРНЫЙ ЭЛЕМЕНТ будет БОЛЬШЕ/МЕНЬШЕ всех остальных или около того, то      |
//  скорость быстрой сортировки сильно падает.                                      |
//                                                                                  |
//      Рассмотрим алгоритм на примере "Разбиение Ломуто!"                          |
//  В общем-то разница между РАЗБИЕНИЕМ ЛОМУТО И РАЗБИЕНИЕМ ХОАРА только в выборе   |
//  опорного элемента. Этот метод рассматривается в качестве учебного, так как выбор|
//  опорного проще, чем в разбиении Хоара, но в среднем менее эффективен. Суть зак- |
//  ключается в том, что за опорный мы принимаем ПОСЛЕДНИЙ элемент в массиве.       |
//__________________________________________________________________________________|

#include <iostream>
#include <vector>
#include <sstream>

typedef int heapData_t;
// heapData_t - тип элемента
// делается это для удобства, например: сейчас мне нужно, чтобы
// в куче были int'ы, а если вдруг я захочу чтобы были строки,
// я ТОЛЬКО ТУТ поменяю int на std::string
//
//-------------------------------------------------------------
//
// создаем прототипы функции
//

// ввод списка значений без терминального элемента
// из одной строки с разделителем - пробелом
std::vector<heapData_t> inputVector();

// сортировка массива
void quickSort(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement);

// Эта функция берет последний элемент массива в качестве ОПОРНОГО

size_t partition(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement);

// распечатка вектора
void printVector(const std::vector<heapData_t> &arr);

int main(){
    std::vector<heapData_t> arr = inputVector();
    size_t firstElement = 0;
    size_t lastElement = arr.size();
    quickSort(arr, firstElement, lastElement - 1);
    printVector(arr);

    return 0;
}

std::vector<heapData_t> inputVector(){
    std::string line;
    getline(std::cin, line);
    std::stringstream lineStream(line);
    std::vector<heapData_t> arr;
    
    while (not lineStream.eof()) {
            heapData_t x;
            lineStream >> x;
            arr.push_back(x);
        }

    return arr;
}

void quickSort(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement){
    if (firstElement < lastElement) {
        size_t partitionIndex = partition(arr, firstElement,
                lastElement);
        quickSort(arr, firstElement, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, lastElement);
    }
}

size_t partition (std::vector<heapData_t> &arr, size_t firstElement,
        size_t lastElement){
    heapData_t pivot = arr[lastElement];
    size_t indexOfSmallerElement = firstElement;
    
    for (size_t index = firstElement; index < lastElement; ++index) {
        if (arr[index] <= pivot) {
            std::swap(arr[indexOfSmallerElement], arr[index]);
            ++indexOfSmallerElement;
        }
    }
    std::swap(arr[indexOfSmallerElement], arr[lastElement]);
    
    return indexOfSmallerElement;
}

void printVector(const std::vector<heapData_t> &arr){
    for (auto &x: arr) {
            std::cout << x << ' ';
    }
    std::cout << '\n';
}
