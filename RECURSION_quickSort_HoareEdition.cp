//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 08.10.2021.
//
//__________________________________________________________________________________
//              РЕКУРСИЯ НА ПРИМЕРЕ "QuickSort - сортировка Тони Хоара"             |
//                                                                                  |
//      Ключевая идея состоит в том, что сортирующее действие осуществляется ДО     |
//  декомпозиции - то есть, ДО ВХОДА В РЕКУРСИЮ! Сначала ПРОИЗВОЛЬНО выбираем некий |
//  ОПОРНЫЙ ЭЛЕМЕНТ из сортируемого массива. Для примера рассмотрим массив:         |
//                                                                                  |
//            [ 2   8   11   10   13   1   3   16   14   6   17   23 ]              |
//                           ^                                                      |
//                           |                                                      |
//             Случайно выбирим ОПОРНЫЙ ЭЛЕМЕНТ                                     |
//      И раскидаем массив на два - СЛЕВА и СПРАВА от ОПОРНОГО ЭЛЕМЕНТА (если       |
//  меньше ОПОРНОГО - налево, больше либо равно - направо.                          |
//             2   8   1   3   6   [10]   11   13   16   14   17   23               |
//                                  ^                                               |
//                                  |                                               |
//                          ОПОРНЫЙ ЭЛЕМЕНТ                                         |
//      Массив предварительно отсортирован относительно ОПОРНОГО ЭЛЕМЕНТА. Далее    |
//  переходим к декомпозиции, то есть проводим такие же действия с ЛЕВОЙ и ПРАВОЙ   |
//  частями:                                                                        |
//      Левая часть: произвольно выбираем ОПОРНЫЙ ЭЛЕМЕНТ:                          |
//             2   8   1   3   6                                                    |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//      И раскидаем массив на два - СЛЕВА и СПРАВА от ОПОРНОГО ЭЛЕМЕНТА (если       |
//  меньше ОПОРНОГО - налево, больше или равно - направо.                           |
//                    [1]   2   8   3   6                                           |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//      Кучка слева от ОПОРНОГО ЭЛЕМЕНТА пуста, а справа нет, значит подобно же     |
//  отсортируем. ВАЖНО! Крайним случаем будет считаться, когда массив будет иметь   |
//  длину, равную ОДНОМУ - массив сортировать не нужно, либо НОЛЬ.                  |
//                                                                                  |
//      У нас появился первый элемент итогового массива: 1, потому что слева от него|
//  ничего нет. Если бы от него слева (или спава при рассмотрении элементов больше  |
//  опорного) находился бы ТОЛЬКО ОДИН элемент,то они попали бы в итоговый массив   |
//  ПАРОЙ! Итак, итоговый массив становиться...                                     |
//                                                                                  |
//            [ 1...                                                 ]              |
//                                                                                  |
//             2   8   3   6                                                        |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//                2   [3]   8   6                                                   |
//                     ^                                                            |
//                     |                                                            |
//             ОПОРНЫЙ ЭЛЕМЕНТ                                                      |
//  Слева оказался один элемент - сортировать не нужно и мы ПАРУ - левый и ОПОРНЫЙ  |
//  включаем в итоговый массив, справа - два, сортируем                             |
//      Итоговый массив становиться...                                              |
//            [ 1   2   3...                                         ]              |
//                         [8]    6                                                 |
//                          ^                                                       |
//                          |                                                       |
//                  ОПОРНЫЙ ЭЛЕМЕНТ                                                 |
//      ПОЛУЧАЕМ:                                                                   |
//                     6   [8]                                                      |
//                          ^                                                       |
//                          |                                                       |
//                  ОПОРНЫЙ ЭЛЕМЕНТ                                                 |
//      Итоговый массив становиться...                                              |
//            [ 1   2   3   6   8   [10]                             ]              |
//                                   ^                                              |
//                                   |                                              |
//                    первый ОПОРНЫЙ ЭЛЕМЕНТ                                        |
//      ДЕЛАЕМ ТОЖЕ САМОЕ С ПРАВОЙ ПОЛОВИНОЙ относительо первого ОПОРНОГО ЭЛЕМЕНТА  |
//      У этой сортировки выбор ОПОРНОГО ЭЛЕМЕНТА имеет очень большое значение!     |
//  Если ОПОРНЫЙ ЭЛЕМЕНТ будет БОЛЬШЕ/МЕНЬШЕ всех остальных или около того, то      |
//  скорость быстрой сортировки сильно падает.                                      |
//                                                                                  |
//      Рассмотрим алгоритм на примере "Разбиение Хоара!"                           |
//    Данная схема использует два индекса (один в начале массива, другой в конце),  |
// которые приближаются друг к другу, пока не найдётся пара элементов, где один     |
// больше опорного и расположен перед ним, а второй меньше и расположен после. Эти  |
// элементы меняются местами. Обмен происходит до тех пор, пока индексы не пере-    |
// секутся. Алгоритм возвращает последний индекс. Схема Хоара эффективнее схемы     |
// Ломуто, так как происходит в среднем в три раза меньше обменов (swap) элементов, |
// и разбиение эффективнее, даже когда все элементы равны. Подобно схеме Ломуто,    |
// данная схема также показывает эффективность в O(n^2), когда входной массив уже   |
// отсортирован. Сортировка с использованием данной схемы нестабильна. Следует      |
// заметить, что конечная позиция опорного элемента необязательно совпадает с       |
// возвращённым индексом.                                                           |
//__________________________________________________________________________________|

#include <iostream>
#include <vector>
#include <sstream>

typedef int heapData_t;
// heapData_t - тип элемента
// делается это для удобства, например: сейчас мне нужно, чтобы
// в куче были int'ы, а если вдруг я захочу чтобы были строки,
// я ТОЛЬКО ТУТ поменяю int на std::string
//
//-------------------------------------------------------------
//
// создаем прототипы функции
//

// ввод списка значений без терминального элемента
// из одной строки с разделителем - пробелом
std::vector<heapData_t> inputVector();

// сортировка массива
void quickSort(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement);

// Данная схема использует два индекса (один в начале массива, другой в конце),
// которые приближаются друг к другу, пока не найдётся пара элементов, где один
// больше опорного и расположен перед ним, а второй меньше и расположен после.
// Эти элементы меняются местами. Обмен происходит до тех пор, пока индексы не
// пересекутся. Алгоритм возвращает последний индекс.
size_t partition(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement);

// распечатка вектора
void printVector(const std::vector<heapData_t> &arr);

int main(){
    std::vector<heapData_t> arr = inputVector();
    size_t firstElement = 0;
    size_t lastElement = arr.size();
    quickSort(arr, firstElement, lastElement - 1);
    printVector(arr);

    return 0;
}

std::vector<heapData_t> inputVector(){
    std::string line;
    getline(std::cin, line);
    std::stringstream lineStream(line);
    std::vector<heapData_t> arr;
    
    while (not lineStream.eof()) {
            heapData_t x;
            lineStream >> x;
            arr.push_back(x);
        }

    return arr;
}

void quickSort(std::vector<heapData_t> &arr,
        size_t firstElement, size_t lastElement){
    if (firstElement < lastElement) {
        size_t partitionIndex = partition(arr, firstElement,
                lastElement);
        quickSort(arr, firstElement, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, lastElement);
    }
}

size_t partition (std::vector<heapData_t> &arr, size_t firstElement,
        size_t lastElement){
    heapData_t pivot = (arr[firstElement] + arr[lastElement]) / 2;
    while (true) {
        while (arr[firstElement] < pivot)
            ++firstElement;
        while (arr[lastElement] > pivot)
            --lastElement;
        if (firstElement  >= lastElement)
            return lastElement;
        std::swap(arr[firstElement++], arr[lastElement--]);
    }
}

void printVector(const std::vector<heapData_t> &arr){
    for (auto &x: arr) {
            std::cout << x << ' ';
    }
    std::cout << '\n';
}
