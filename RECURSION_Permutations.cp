//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 07.10.2021.
//
//__________________________________________________________________________________
//           РЕКУРСИЯ НА ПРИМЕРЕ "Генерация перестановок - PERMUTATIONS"            |
//                                                                                  |
//      Постановка задачи:                                                          |
//                                                                                  |
//      Нужно сгенерировать всевозможные варианты перестановок чисел определенной   |
//  длины, введенной пользователем. Это означает, что в сгенерированных вариантах   |
//  числа повторяться НЕ будут. Например, вводим длину генерации 3, значит у нас    |
//  будет 6 вариантов: 012 021 102 120 201 210, то есть количество возможных вариан-|
//  тов равно n!, где n - длина генерации.                                          |
//                                                                                  |
//  В этом дереве мы распечатываем всевозможные варианты, даже с повторяющимеся     |
//  элементами.                                                                     |
//                                                                                  |
//                                      ^                                           |
//                                     /|\                                          |
//                           _________/ | \_________                                |
//                          /           |           \                               |
//                         /            |            \                              |
//                        /             |             \                             |
//                       /              |              \                            |
//                      /               |               \                           |
//                     /                |                \                          |
//                    /                 |                 \                         |
//                   0                  1                  2                        |
//                /  |  \            /  |  \            /  |  \                     |
//               /   |   \          /   |   \          /   |   \                    |
//              /    |    \        /    |    \        /    |    \                   |
//             0     1     2      0     1     2      0     1     2                  |
//            /|\   /|\   /|\    /|\   /|\   /|\    /|\   /|\   /|\                 |
//           / | \ / | \ / | \  / | \ / | \ / | \  / | \ / | \ / | \                |
//           0 1 2 0 1 2 0 1 2  0 1 2 0 1 2 0 1 2  0 1 2 0 1 2 0 1 2                |
//                                                                                  |
//                                                                                  |
//  В этом дереве мы "обрубим" лишние ветки с повторяющимеся элементами:            |
//                                                                                  |
//                                                                                  |
//                                      ^                                           |
//                                     /|\                                          |
//                           _________/ | \_________                                |
//                          /           |           \                               |
//                         /            |            \                              |
//                        /             |             \                             |
//                       /              |              \                            |
//                      /               |               \                           |
//                     /                |                \                          |
//                    /                 |                 \                         |
//                   0                  1                  2                        |
//                /  |  \            /  |  \            /  |  \                     |
//     повтор    x   |   \          /   x  повтор      /   |   x    повтор          |
//           \  /    |    \        /    | /   \       /    |    \  /                |
//             0     1     2      0     1     2      0     1     2                  |
//            /|\   /|\   /|\    /|\   /|\   /|\    /|\   /|\   /|\                 |
//           / | \ x x \ x | x  x x \ / | \ / x x  x | x / x x / | \                |
//           0 1 2 0 1 2 0 1 2  0 1 2 0 1 2 0 1 2  0 1 2 0 1 2 0 1 2                |
//                /  |   |   |  | |           | |  |   |   | |                      |
//              повтор  повтор повтор       повтор повтор повтор                    |
//                                                                                  |
//  ОСТАЕТСЯ после обрубаний:                                                       |
//                                                                                  |
//                                                                                  |
//                                      ^                                           |
//                                     /|\                                          |
//                           _________/ | \_________                                |
//                          /           |           \                               |
//                         /            |            \                              |
//                        /             |             \                             |
//                       /              |              \                            |
//                      /               |               \                           |
//                     /                |                \                          |
//                    /                 |                 \                         |
//                   0                  1                  2                        |
//                   |  \            /     \            /  |                        |
//                   |   \          /       \          /   |                        |
//                   |    \        /         \        /    |                        |
//                   1     2      0           2      0     1                        |
//                    \    |       \         /       |    /                         |
//                     \   |        \       /        |   /                          |
//                     2   1        2       0        1   0                          |
//                                                                                  |
//      Остается 6 вариантов: 012 021 102 120 201 210                               |
//                                                                                  |
//  Решение:                                                                        |
//                                                                                  |
//      Нам понадобится ПРЕФИКС, чтобы во-первых, было что распечатывать, во-вторых,|
//  чтобы там хранилась цифра, которая НЕ должна повторяться. Я могу использовать   |
//  только те цифры, которых раньше не было. Факт того, что такая-то цифра была     |
//  использована, реализую с помощью массива bool'ов. Создаю массив buffer[], в     |
//  котором будут рождаться сгенерируемые перестановки. Нужно также знать текущий   |
//  элемент - создадим current. На вопрос - сколько же цифр будет, то есть какой    |
//  длины будет каждая генерация - будет отвечать переменная number. Отмечать уже   |
//  испольщованные цифры будет bool'евский массив used[].                           |
//                                                                                  |
//      ФУНКЦИЯ:                                                                    |
//                                                                                  |
//void permutations(int16_t number, int16_t current, int16_t buffer[], bool used[]){|
//  if (current == number) {                                                        |
//      for (int i = 0; i < number; ++i)                                            |
//          std::cout << buffer[i] << '\t';                                         |
//      std::cout << '\n';                                                          |
//  } else {                                                                        |
//  for (int16_t variant = 0; variant < number; ++variant) {                        |
//      if (not used[variant]) {                                                    |
//          buffer[current] = variant;                                              |
//          used[variant] = true;                                                   |
//          permutations(number, current + 1, buffer, used);                        |
//          used[variant] = false;                                                  |
//          }                                                                       |
//      }                                                                           |
//  }                                                                               |
//}                                                                                 |
//                                                                                  |
//      Как же отличить крайний случай? Когда ТЕКУЩАЯ ПОЗИЦИЯ (current) будет равна |
//  длине ГЕНЕРИРУЕМОЙ ПОСЛЕДОВАТЕЛЬНОСТИ (number), значит мы окажемся за пределами |
//  массива. Например, ДЛИНА ПОСЛЕДОВАТЕЛЬНОСТИ (number) равна 3, то если ТЕКУЩАЯ   |
//  ПОЗИЦИЯ (current) будет указывать на индекс 3, а это ЧЕТВЕРТЫЙ индекс (начиная  |
//  с нуля), значит мы вышли за пределы нашего массива.                             |
//                                                                                  |
//      В рекуррентом варианте у нас будет следующее:                               |
//  Необходимо в текущую позицию положить всевозможные варианты, начиная с нуля и   |
//  до number НЕ включительно! Для этого будем использовать цикл:                   |
//                          for (int16_t variant = 0; variant < number; ++variant)  |
//  Но нужно отсекать уже использованные варианты! Для этого используем условный    |
//  оператор, а также bool'евский массив с флагами:                                 |
//                          if (not used[variant])                                  |
//      Для лучшего понимания нужно сказать следующее:                              |
//  1.  Наш массив с флагами заполнен false'ми - в функции main есть цикл:          |
//                          for (int i = 0; i < lengthForGenerations; ++i)          |
//                              used[i] = false;                                    |
//  Этим мы устанавливаем тот факт, что ни один variant еще не был использован.     |
//  2.  Конструкция not used[variant] при флаге равном false приобретает следующий  |
//  вид: not false - то есть true. Значит, что цифра еще не использовалась,         |
//  и мы кладем вариант в текущую позицию в массиве для генерации:                  |
//                          buffer[current] = variant;                              |
//  Отмечаем, что цифра variant только что использовалась, чтобы более глубокие     |
//  уровни рекурсии более эту цифру НЕ использовали:                                |
//                          used[variant] = true;                                   |
//  И рекуррентно вызываем функцию для генерации цифры в следующей (current + 1)    |
//  позиции.                                                                        |
//  Но есть еще один момент! Когда будет переход к другой ветке, необходимо         |
//  отменить факт использования цифры, то есть текущего варианта к моменту, когда я |
//  возвращаюсь из рекурсии - более глубокого уровня перебора. Для этого:           |
//                          used[variant] = false;                                  |
//__________________________________________________________________________________|

#include <iostream>

//  объявление функции
//
//  number - длина генерируемой последовательности
//  current - текущая позиция для генерации
//  buffer[] - массив, в котором будет осуществяться генерация, он же ПРЕФИКС
//  used[] - массив для проверки использования/не использования цифры
void permutations(int16_t number, int16_t current, int16_t buffer[], bool used[]);

int main(int argc, const char * argv[]) {
    //  стартовая текущая позиция
    const int16_t current = 0;
    //  длина генерации
    int16_t lengthForGenerations;
    std::cout << "Введите длину для генерации перестановок: ";
    std::cin >> lengthForGenerations;
    
    //  условие: слишком большое число отсекаем
    if (lengthForGenerations > 10) {
        std::cout << "Число слишком большое!\n";
        return 1;
    //  также число должно быть БОЛЬШЕ НУЛЯ, можно и меньше, но нечего распечатывать
    } else if (lengthForGenerations <= 0) {
        std::cout << "Число должно быть БОЛЬШЕ НУЛЯ!\n";
        return 1;
    }
    
    //  создаем массив для генерации
    int16_t buffer[lengthForGenerations];
    //  создаем массив для уже исползованных цифр
    bool used[lengthForGenerations];

    //  заполняем массив, тем самым указав, что на момент старта генерации
    //  перестановок, то есть ДО ПЕРВОГО ВЫЗОВА ФУНКЦИИ, ни одно число еще
    //  не использовалось
    for (int i = 0; i < lengthForGenerations; ++i)
        used[i] = false;
    
    //  вызываем функцию
    permutations(lengthForGenerations, current, buffer, used);
    
    return 0;
}

//  определение функции
void permutations(int16_t number, int16_t current, int16_t buffer[], bool used[]){
    if (current == number) {        // крайний случай
        for (int i = 0; i < number; ++i)
            std::cout << buffer[i] << '\t';
        std::cout << '\n';
    } else {                        // рекуррентный случай
        for (int16_t variant = 0; variant < number; ++variant) {
            if (not used[variant]) { // обрезаем ветви дерева
                buffer[current] = variant;
                used[variant] = true;
                permutations(number, current + 1, buffer, used);
                used[variant] = false;
            }
        }
    }
}
