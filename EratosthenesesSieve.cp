//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 21.09.2021.
//
//__________________________________________________________________________________
//                                Решето Эратосфена                                 |
//                                                                                  |
//  Задача:                                                                         |
//          найти все простые числа от 2 до заданного числа N                       |
//                                                                                  |
//  Решение:                                                                        |
//                                                                                  |
//  Имеется ряд:                                                                    |
//    2      3       4      5       6      7      8      9      10     11     12    |
//   13     14      15      16      17     18     19     20     21     22     23    |
//   24     25      26      27      28     29     30     31     32     33     34    |
//   35     36      37      38      39     40     41     42     43     44     45    |
//                                                                                  |
//  Берем ОПОРНОЕ число (2) и вычеркиваем все числа, кратные текущему числу         |
//   [2]     3              5              7             9             11           |
//   13             15              17            19            21            23    |
//          25              27             29            31            33           |
//   35             37              39            41            43            45    |
//                                                                                  |
//  Берем ОПОРНОЕ число (3) и вычеркиваем все числа, кратные текущему числу         |
//   [2]    [3]             5              7                           11           |
//   13                             17            19                          23    |
//          25                             29            31                         |
//   35             37                            41            43                  |
//                                                                                  |
//  Берем ОПОРНОЕ число (5) и вычеркиваем все числа, кратные текущему числу         |
//   [2]    [3]            [5]             7                           11           |
//   13                             17            19                          23    |
//                                         29            31                         |
//                  37                            41            43                  |
//  Из этого можно видеть, что мы можем вычеркивать все числа, кратные КВАДРАТУ     |
//  ТЕКУЩЕГО ЧИСЛА                                                                  |
//                                                                                  |
//  Следующее опорное число - СЕМЬ. Но можно гарантировать, что следующее вычерк-   |
//  нутое число будет СЕМЬ В КВАДРАТЕ, то есть 49, а это за пределами нашего ряда.  |
//  Выписываем наши оставшиеся числа - это и будет список всех простых чисел в этом |
//  диапазоне:                                                                      |
//             2   3   5   7   11  13  17  19  23  29   31  37  41  43              |
//                                                                                  |
//  Рассмотрим работу программы:                                                    |
//  Есть несколько тонкостей. Например, мы не будем хранить сами числа, нам нужен   |
//  только сам ФАКТ ЗАЧЕРКНУТОСТИ. Начинать мы будем не с 0 или 1, а с ДВОЙКИ!      |
//                                                                                  |
//  1.  Пользователь вводит с клавиатуры КРАЙНЕЕ ЧИСЛО, до которого включительно    |
//  нужно найти все простые числа                                                   |
//  2.  Создаем массив из BOOL-евских элементов, число которых равно введенному выше|
//  Так как индексы массивов начинаются с НУЛЯ, то, чтобы включить последний элемент|
//  среди которых мы будем искать простые, нам нужно создать массив размером +1     |
//  3.  Предполагаем, что все элементы простые и заполняем массив только TRUE       |
//  4.  Затем, начиная с индекса 2 в квадрате (это математически обосновано!),      |
//  с шагом, равным номеру индекса, начинаем вычеркивать (помечать их как FALSE)    |
//  5.  После берем за опорный элемент 3 и повторяем 4-ый шаг, только с ТРОЙКОЙ     |
//  6.  Следующий элемент (ЧЕТВЕРКА) у нас уже вычеркнут, значит выбираем в качестве|
//  опорного ПЯТЬ, 5 в квадрате равно 25, значит при опорном элементе 5 первое      |
//  вычеркнутое число будет 25... В общем повторяем циклически действия, пока у нас |
//  не закончится введенный ряд чисел. Для примера возмем ряд, последним числом     |
//  которого будет 48. Значит последним опорным элементом будет 6, так как 7 в квад-|
//  рате будет равно 49.                                                            |
//  7.  Распечатываем простые числа. Так как индекс массива СОВПАДАЕТ с числом,     |
//  которое лежит в ячейке с этим индексом, мы будем распечатывать ИНДЕКС, а не     |
//  само число, хранимое под этим индексом. НАПОМНЮ, что массив у нас состоит из    |
//  BOOL-евских элементов, там только TRUE или FALSE. Распечатываются ТОЛЬКО номера |
//  индексов, в которых транится TRUE!                                              |
//__________________________________________________________________________________|

#include <iostream>


int main(int argc, const char * argv[]) {
    std::cout << "Введите лимит для РЕШЕТА Эратосфена: ";
    int lengthOfSieve;                  // длина РЕШЕТА
    std::cin >> lengthOfSieve;

    bool sieve[lengthOfSieve + 1];      // + 1, чтобы ВСЕ вошли, включая последний эл.
    // заполняем массив, что у нас все простые, просто предпологаем, что это так.
    for (int i = 2; i < lengthOfSieve; ++i) {
        sieve[i] = true;
    }
    //  Начинаем с индекса 2, а там хранится число 2
    int index = 2;
    // начиная с кратного КВАДРАТУ текущего и пока не дойдем до конца нашего решета
    while (index*index <= lengthOfSieve) {
         if (sieve[index]) { // если в элементе с индексом index лежит НЕвычеркнутое
             // то с индекса в квадрате, прибавляя индекс и до конца
            for (int y = index*index; y <= lengthOfSieve; y += index) {
                sieve[y] = false;       // вычеркиваем числа
            }
        }
        index++;
    }
    // Распечатываем простые числа
    // так как индекс массива СОВПАДАЕТ с числом, которое лежит в ячейке с этим индексом
    // мы будем распечатывать ИНДЕКС, а не само число, хранимое под этим индексом.
    // НАПОМНЮ, что массив у нас BOOL элементов, там только TRUE или FALSE
    for (int i = 2; i < lengthOfSieve; ++i) {
        if(sieve[i]) {                  // если число НЕвычеркнутое
            std::cout << i << '\t';     // РАСПЕЧАТЫВАЕМ его!
        }
    }
    std::cout << std::endl;
    
    return 0;
}
