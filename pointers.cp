//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 07.09.2021.
//__________________________________________________________________________________
//                              СТРУКТУРЫ И УКАЗАТЕЛИ.                              |
//                                                                                  |
//  СТРУКТУРА в с++ - это пользовательский тип данных. Всего в с++ ЧЕТЫРЕ основных  |
//  пользовательских (произвольных) типа: перечисления(ENUM), объединения(UNION),   |
//  структуры(STRUCT) и классы(CLASS).                                              |
//      Описание:                                                                   |
//  [ключевое слово] struct [имя структуры] node_t {                                |
//     [тип переменной] int [имя переменной] data; <- заканчивается на ';'          |
//     [тип переменной] node_t* [имя переменной] next;                              |
//  }; <- заканчивается на ';'                                                      |
//                                                                                  |
//                                                                                  |
//  Нужно обратить внимание на несколько моментов:                                  |
//  1) переменные, содержащиеся в структуре, называются ПОЛЯМИ.                     |
//  2) объект этого же типа [node_t] не может быть ПОЛЕМ этого типа!                |
//  А вот АДРЕС НА НЕГО [node_t*] может быть                                        |
//  3) как правило, в имени структуры есть приписка [_t] - это для того,            |
//  чтобы было понятно, что это ТИП.                                                |
//__________________________________________________________________________________|

#include <iostream>

// структура
struct node_t {
    int data;               // просто какие-то данные
    node_t *next;           // указатель на что-то - определим в main()
};

// определение константы
const int lengthOfArr = 5;

// объявлние функции
void goThrough(node_t *p);

int main(int argc, const char * argv[]) {
    
    // создаем массив из lengthOfArr СТРУКТУР
    node_t arr[lengthOfArr];
    
    // заполним струткуру: в data мы кладем значение i + 1, а в
    // next - указатель - мы кладем адрес следующей структуры
    for (int i = 0; i < lengthOfArr; ++i) {
        arr[i].data = i + 1;        // просто чтобы начиналось с '1'
        // в нулевую ячейку сладем адрес + 1, то есть адрес следующий ячейки
        arr[i].next = arr + i + 1;  // arr[0] тоже самое что и &(*(arr + 0)),
                                    // а разыменование '*' и взятие адреса '&'
                                    // это взаимоуничтожающе операции
    }
    // после завершения цикла у нас создается опасная ситуация:
    // при i равном 4 мы получаем указатель на arr[5] (arr + 4 + 1),
    // а его нет - последний элемент в массиве arr[4]
    // значит нам нужно в arr[4].next положить нулевой указатель,
    // чтобы вовремя остановиться
    arr[4].next = nullptr;
    
    // просто кладем что-то сильно отличное в последюю ячейку,
    // чтобы просто было более явно видно конец
    arr[4].data = 777;
    
    // указатель на начало
    node_t *pBegin = arr;           // тоже что и node_t *pBegin = arr[0];
    
    goThrough(pBegin);
    
    return 0;
}

// реализация функции
void goThrough(node_t *p) {
    // пока указатель НЕ равен НУЛЕВОМУ УКАЗАТЕЛЮ
    while (p != nullptr) {
        // распечатываем то, что находится в поле data в структуре
        // по адресу, начиная с p = pBegin
        std::cout << p->data << '\n';       // можно по старинке (*p).data
        // а потом меняем адрес согласно
        // что у нас в структуре по текущему
        // адресу указано в поле next адрес
        // следующей структуры см. цикл в main()
        p = (*p).next;                      // но лучше использовать p->next,
    }                                       // то есть разыменование вместе с
}                                           // доступом к полю
