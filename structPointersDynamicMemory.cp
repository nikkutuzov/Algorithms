//
//  main.cpp
//  cppEdu
//
//  Created by Николай Кутузов on 08.09.2021.
//
//__________________________________________________________________________________
//               СТРУКТУРЫ, УКАЗАТЕЛИ и димамческое выделение памяти.               |
//                                                                                  |
//  СТРУКТУРА в с++ - это пользовательский тип данных. Всего в с++ ЧЕТЫРЕ основных  |
//  пользовательских (произвольных) типа: перечисления(ENUM), объединения(UNION),   |
//  структуры(STRUCT) и классы(CLASS).                                              |
//      Описание:                                                                   |
//  например структура:                                                             |
//                                                                                  |
//  struct node_t {                                                                 |
//      int data;                                                                   |
//      node_t *next;                                                               |
//  };                                                                              |
//                                                                                  |
//  ключевое слово                                                                  |
//      ||имя структуры                                                             |
//      ||     ||                                                                   |
//      \/     \/                                                                   |
//   struct node_t {                                                                |
//  тип переменной                                                                  |
//      ||имя переменной                                                            |
//      ||   ||                                                                     |
//      \/   \/                                                                     |
//      int data; <- заканчивается на ';'                                           |
//      node_t* next;                                                               |
//        /\     /\                                                                 |
//        ||     ||                                                                 |
// тип переменной||                                                                 |
//          имя переменной                                                          |
//  }; <- заканчивается на ';'                                                      |
//                                                                                  |
//  создаем структуру node_t newStructure;                                          |
//  обращение к полю: newSrtucture.data = 13;                                       |
//                                                                                  |
//  Нужно обратить внимание на несколько моментов:                                  |
//  1) переменные, содержащиеся в структуре, называются ПОЛЯМИ.                     |
//  2) объект этого типа [node_t] не может быть ПОЛЕМ этого же объекта!             |
//  А вот УКАЗАТЕЛЬ НА НЕГО (на тип) [node_t*] - может быть                         |
//  3) как правило, в имени структуры есть приписка [_t] - это для того,            |
//  чтобы было понятно, что это ТИП.                                                |
//                                                                                  |
//  Для динамического выделения памяти используется ключевое слово new              |
//  НО! Важно не забывать высвобождать динамически выделенную память, для этого     |
//  используется ключевое слово delete. Для массивов delete[].                      |
//                                                                                  |
//  ПРИМЕР:                                                                         |
//                                                                                  |
//  есть структура:                                                                 |
//                                                                                  |
//  struct node_t {                                                                 |
//      int data;               // просто какие-то данные типа int                  |
//      node_t *next;           // указатель на переменную типа node_t              |
//  };                                                                              |
//                                                                                  |
//  выделяем память под структуру:                                                  |
//                          node_t *pBegin = new node_t;                            |
//                            /\      /\      /\    /\                              |
//                            ||      ||      ||    ||                              |
//                            ||    указатель ||    под что именно выделяем память- |
//              тип данных, на который        ||    здесь - структура node_t        |
//               указывает указатель          ||                                    |
//                                  new - команда выделения                         |
//                                          памяти                                  |
//  Здесь получается, что указатель pBegih указывает на адрес структуры, для        |
//  которой только что выделили[new] память. [node_t] перед [*pBedin] говорит       |
//  о том, что указатель pBegit указывает на ячейку памяти, в которой храняться     |
//  данные типа node_t                                                              |
//  Для высвобождения памяти:                                                       |
//                              delete pBegin;                                      |
//__________________________________________________________________________________|

#include <iostream>

// структура
struct node_t {
    int data;               // просто какие-то данные типа int
    node_t *next;           // указатель на переменную типа node_t
};

// определение константы
const int count = 5;

// объявлние функции
void goThrough(node_t *p);

int main(int argc, const char * argv[]) {
    
    node_t *pBegin = new node_t;            // выделяем память для структуры типа
                                            // node_t и кладем ее адрес в указатель
    node_t *p = pBegin;                     // pBegin приваиваем указателю p адрес
                                            // первой структуры, на которую
                                            // указывает pBbegin
    
    // заполним струткуру: в data мы кладем значение i + 1, а в
    // next - указатель - мы кладем адрес следующей структуры
    for (int i = 0; i < count; ++i) {
        p->data = i + 1;            // просто чтобы значения начинались с '1'
        p->next = new node_t;       // выделяем память под следующую структуру
                                    // кладем в указатель next - он же ПОЛЕ
                                    // структуры - адрес следующей, вновь созданной
        p = p->next;                // структуры кладем в указатель p адрес только
                                    // что сознанной структуры
    }
    // так как структур у нас 5 (см. count) нужно в поле next текущей структуры
    // указать нулевой указатель, а не указатель на НЕСУЩЕСТВУЮЩУЮ шестую структуру
    p->next = nullptr;
    // ну и просто показать, что этим мы завершили цепочку
    p->data = 777;
    
    goThrough(pBegin);
    
// высвобождаем выделенную память
    // сначала мы присваиваем указателю p адрес первой структуры
    p = pBegin;
    // проходим по структурам, начиная с первой нами созданной
    // (node_t *pBegin = new node_t;), в ней - в ПОЛЕ next содержится адрес
    // следующей структуры. Создаем новый указатель p1 и помещаем в него адрес на
    // вторую структуру, в которой - в ПОЛЕ next хранится адрес третьей...
    // и так по цепочке. Затем высвобождаем от структур память. Получилось куцо,
    // но для учебного примера достаточно информативно. В реальности такого лучше
    node_t *p1;
    p1 = p->next;
    node_t *p2;
    p2 = p1->next;
    node_t *p3;
    p3 = p2->next;
    node_t *p4;
    p4 = p3->next;
    node_t *p5;
    p5 = p4->next;
    delete pBegin;
    delete p1;
    delete p2;
    delete p3;
    delete p4;
    delete p5;
    
    return 0;
}

// реализация функции
void goThrough(node_t *p) {
    // пока указатель НЕ равен НУЛЕВОМУ УКАЗАТЕЛЮ
    while (p != nullptr) {
        // распечатываем то, что находится в поле data в структуре
        // по адресу, начиная с p = pBegin
        std::cout << p->data << '\n';       // можно по старинке (*p).data
        // а потом меняем адрес согласно
        // что у нас в структуре по текущему
        // адресу указано в поле next адрес
        // следующей структуры см. цикл в main()
        p = (*p).next;                      // но лучше использовать p->next,
    }                                       // то есть разыменование вместе с
}                                           // доступом к полю
